/*
 * Copyright [2024] [envite consulting GmbH]
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 *
 */

package io.kadai.adapter.integration;

import static org.assertj.core.api.Assertions.assertThat;

import io.kadai.adapter.camunda.outbox.rest.resource.CamundaTaskEventListResource;
import io.kadai.adapter.impl.KadaiTaskStarter;
import io.kadai.adapter.impl.KadaiTaskTerminator;
import io.kadai.adapter.systemconnector.camunda.api.impl.HttpHeaderProvider;
import io.kadai.adapter.test.KadaiAdapterTestApplication;
import io.kadai.common.api.security.UserPrincipal;
import io.kadai.common.test.security.JaasExtension;
import io.kadai.common.test.security.WithAccessId;
import io.kadai.common.test.util.ParallelThreadHelper;
import io.kadai.task.api.TaskState;
import io.kadai.task.api.models.TaskSummary;
import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.security.auth.Subject;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.http.HttpHeaders;
import org.springframework.test.context.ContextConfiguration;

/**
 * Test class to test the conversion of tasks generated by Camunda BPM to Kadai tasks.
 */
@SpringBootTest(
    classes = KadaiAdapterTestApplication.class,
    webEnvironment = WebEnvironment.DEFINED_PORT)
@AutoConfigureWebTestClient
@ExtendWith(JaasExtension.class)
@ContextConfiguration
@SuppressWarnings("checkstyle:LineLength")
class TestLockingAndClustering extends AbsIntegrationTest {

  private static final String BASIC_OUTBOX_PATH = "http://localhost:10020/outbox-rest/events";

  @Autowired
  private HttpHeaderProvider httpHeaderProvider;
  @Autowired
  KadaiTaskStarter kadaiTaskStarter;
  @Autowired
  KadaiTaskTerminator kadaiTaskTerminator;

  @Value("${kadai-system-connector-camundaSystemURLs}")
  private String configuredSystemConnectorUrls;

  @WithAccessId(
      user = "teamlead_1",
      groups = {"taskadmin"})
  @Test
  void should_LockEventsForTheCorrectTime_When_Getting() {
    this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_user_task_process", "");

    String url = BASIC_OUTBOX_PATH + "?lock-for=10";

    HttpHeaders headers = httpHeaderProvider.getHttpHeadersForOutboxRestApi();
    CamundaTaskEventListResource answer =
        restClient.get()
            .uri(url)
            .headers(httpHeaders -> httpHeaders.addAll(headers))
            .retrieve()
            .toEntity(CamundaTaskEventListResource.class)
            .getBody();

    assertThat(answer).isNotNull();
    assertThat(answer.getCamundaTaskEvents()).hasSize(1);
    answer =
        restClient.get()
            .uri(url)
            .headers(httpHeaders -> httpHeaders.addAll(headers))
            .retrieve()
            .toEntity(CamundaTaskEventListResource.class)
            .getBody();

    assertThat(answer).isNotNull();
    assertThat(answer.getCamundaTaskEvents()).isEmpty();

    try {
      Thread.sleep(10000);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    answer =
        restClient.get()
            .uri(url)
            .headers(httpHeaders -> httpHeaders.addAll(headers))
            .retrieve()
            .toEntity(CamundaTaskEventListResource.class)
            .getBody();

    assertThat(answer).isNotNull();
    assertThat(answer.getCamundaTaskEvents()).hasSize(1);

  }

  @WithAccessId(
      user = "teamlead_1",
      groups = {"taskadmin"})
  @Test
  void should_UnlockTheEvent() {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_user_task_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(1);
    String urlWithLock = BASIC_OUTBOX_PATH + "?lock-for=10";

    HttpHeaders headers = httpHeaderProvider.getHttpHeadersForOutboxRestApi();
    CamundaTaskEventListResource answer = restClient.get()
            .uri(urlWithLock)
            .headers(httpHeaders -> httpHeaders.addAll(headers))
            .retrieve()
            .toEntity(CamundaTaskEventListResource.class)
            .getBody();
    assertThat(answer).isNotNull();
    assertThat(answer.getCamundaTaskEvents()).hasSize(1);
    int eventId = answer.getCamundaTaskEvents().get(0).getId();
    String urlWithUnlock = BASIC_OUTBOX_PATH + "/unlock-event/" + eventId;

    restClient.post()
        .uri(urlWithUnlock)
        .headers(httpHeaders -> httpHeaders.addAll(headers))
        .retrieve()
        .toEntity(Void.class);
    answer =
        restClient.get()
            .uri(urlWithLock)
            .headers(httpHeaders -> httpHeaders.addAll(headers))
            .retrieve()
            .toEntity(CamundaTaskEventListResource.class)
            .getBody();
    assertThat(answer).isNotNull();
    assertThat(answer.getCamundaTaskEvents()).hasSize(1);

  }

  @WithAccessId(user = "taskadmin")
  @Test
  void should_CreateCorrespondingKadaiTasksConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_execution_process", "");
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("admin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          kadaiTaskStarter.retrieveReferencedTasksAndCreateCorrespondingKadaiTasks();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    for (String externalId : camundaTaskIds) {
      List<TaskSummary> tasks = taskService.createTaskQuery().externalIdIn(externalId).list();
      assertThat(tasks).hasSize(1);
    }
  }

  @WithAccessId(user = "taskadmin")
  @Test
  void should_FinishCorrespondingKadaiTasksConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_execution_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    Thread.sleep((long) (this.adapterTaskPollingInterval * 1.2));

    for (String camundaTaskId : camundaTaskIds) {
      this.camundaProcessengineRequester.completeTaskWithId(camundaTaskId);
    }
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("taskadmin", "taskadmin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          kadaiTaskTerminator.retrieveFinishedReferencedTasksAndTerminateCorrespondingKadaiTasks();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
    for (String externalId : camundaTaskIds) {
      List<TaskSummary> tasks = taskService.createTaskQuery().externalIdIn(externalId).list();
      assertThat(tasks).hasSize(1);
      assertThat(tasks.get(0).getState()).isEqualTo(TaskState.COMPLETED);
    }
  }

  private Runnable getRunnableTest(List<String> accessIds, PrivilegedAction<Void> action) {
    return () -> {
      Subject subject = new Subject();
      subject.getPrincipals().add(new UserPrincipal(accessIds.remove(0)));
      Subject.doAs(subject, action);
    };
  }

}
